// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class IssuedEToken extends ethereum.Event {
  get params(): IssuedEToken__Params {
    return new IssuedEToken__Params(this);
  }
}

export class IssuedEToken__Params {
  _event: IssuedEToken;

  constructor(event: IssuedEToken) {
    this._event = event;
  }

  get ePool(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get eToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get amountA(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get amountB(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get user(): Address {
    return this._event.parameters[5].value.toAddress();
  }
}

export class RecoveredToken extends ethereum.Event {
  get params(): RecoveredToken__Params {
    return new RecoveredToken__Params(this);
  }
}

export class RecoveredToken__Params {
  _event: RecoveredToken;

  constructor(event: RecoveredToken) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class RedeemedEToken extends ethereum.Event {
  get params(): RedeemedEToken__Params {
    return new RedeemedEToken__Params(this);
  }
}

export class RedeemedEToken__Params {
  _event: RedeemedEToken;

  constructor(event: RedeemedEToken) {
    this._event = event;
  }

  get ePool(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get eToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get amountA(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get amountB(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get user(): Address {
    return this._event.parameters[5].value.toAddress();
  }
}

export class SetController extends ethereum.Event {
  get params(): SetController__Params {
    return new SetController__Params(this);
  }
}

export class SetController__Params {
  _event: SetController;

  constructor(event: SetController) {
    this._event = event;
  }

  get controller(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class SetEPoolApproval extends ethereum.Event {
  get params(): SetEPoolApproval__Params {
    return new SetEPoolApproval__Params(this);
  }
}

export class SetEPoolApproval__Params {
  _event: SetEPoolApproval;

  constructor(event: SetEPoolApproval) {
    this._event = event;
  }

  get ePool(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get approval(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class SetMaxFlashSwapSlippage extends ethereum.Event {
  get params(): SetMaxFlashSwapSlippage__Params {
    return new SetMaxFlashSwapSlippage__Params(this);
  }
}

export class SetMaxFlashSwapSlippage__Params {
  _event: SetMaxFlashSwapSlippage;

  constructor(event: SetMaxFlashSwapSlippage) {
    this._event = event;
  }

  get maxFlashSwapSlippage(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class SmartExposureEPoolPeriphery extends ethereum.SmartContract {
  static bind(address: Address): SmartExposureEPoolPeriphery {
    return new SmartExposureEPoolPeriphery(
      "SmartExposureEPoolPeriphery",
      address
    );
  }

  ePools(param0: Address): boolean {
    let result = super.call("ePools", "ePools(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBoolean();
  }

  try_ePools(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("ePools", "ePools(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  eTokenForMinInputAmountA_Unsafe(
    ePool: Address,
    eToken: Address,
    minInputAmountA: BigInt
  ): BigInt {
    let result = super.call(
      "eTokenForMinInputAmountA_Unsafe",
      "eTokenForMinInputAmountA_Unsafe(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(minInputAmountA)
      ]
    );

    return result[0].toBigInt();
  }

  try_eTokenForMinInputAmountA_Unsafe(
    ePool: Address,
    eToken: Address,
    minInputAmountA: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "eTokenForMinInputAmountA_Unsafe",
      "eTokenForMinInputAmountA_Unsafe(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(minInputAmountA)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  eTokenForMinInputAmountB_Unsafe(
    ePool: Address,
    eToken: Address,
    minInputAmountB: BigInt
  ): BigInt {
    let result = super.call(
      "eTokenForMinInputAmountB_Unsafe",
      "eTokenForMinInputAmountB_Unsafe(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(minInputAmountB)
      ]
    );

    return result[0].toBigInt();
  }

  try_eTokenForMinInputAmountB_Unsafe(
    ePool: Address,
    eToken: Address,
    minInputAmountB: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "eTokenForMinInputAmountB_Unsafe",
      "eTokenForMinInputAmountB_Unsafe(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(minInputAmountB)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  factory(): Address {
    let result = super.call("factory", "factory():(address)", []);

    return result[0].toAddress();
  }

  try_factory(): ethereum.CallResult<Address> {
    let result = super.tryCall("factory", "factory():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getController(): Address {
    let result = super.call("getController", "getController():(address)", []);

    return result[0].toAddress();
  }

  try_getController(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getController",
      "getController():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  issueForMaxTokenA(
    ePool: Address,
    eToken: Address,
    amount: BigInt,
    maxInputAmountA: BigInt,
    deadline: BigInt
  ): boolean {
    let result = super.call(
      "issueForMaxTokenA",
      "issueForMaxTokenA(address,address,uint256,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(maxInputAmountA),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBoolean();
  }

  try_issueForMaxTokenA(
    ePool: Address,
    eToken: Address,
    amount: BigInt,
    maxInputAmountA: BigInt,
    deadline: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "issueForMaxTokenA",
      "issueForMaxTokenA(address,address,uint256,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(maxInputAmountA),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  issueForMaxTokenB(
    ePool: Address,
    eToken: Address,
    amount: BigInt,
    maxInputAmountB: BigInt,
    deadline: BigInt
  ): boolean {
    let result = super.call(
      "issueForMaxTokenB",
      "issueForMaxTokenB(address,address,uint256,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(maxInputAmountB),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBoolean();
  }

  try_issueForMaxTokenB(
    ePool: Address,
    eToken: Address,
    amount: BigInt,
    maxInputAmountB: BigInt,
    deadline: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "issueForMaxTokenB",
      "issueForMaxTokenB(address,address,uint256,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(maxInputAmountB),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  keeperSubsidyPool(): Address {
    let result = super.call(
      "keeperSubsidyPool",
      "keeperSubsidyPool():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_keeperSubsidyPool(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "keeperSubsidyPool",
      "keeperSubsidyPool():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  maxFlashSwapSlippage(): BigInt {
    let result = super.call(
      "maxFlashSwapSlippage",
      "maxFlashSwapSlippage():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_maxFlashSwapSlippage(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "maxFlashSwapSlippage",
      "maxFlashSwapSlippage():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maxOutputAmountAForEToken(
    ePool: Address,
    eToken: Address,
    amount: BigInt
  ): BigInt {
    let result = super.call(
      "maxOutputAmountAForEToken",
      "maxOutputAmountAForEToken(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBigInt();
  }

  try_maxOutputAmountAForEToken(
    ePool: Address,
    eToken: Address,
    amount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "maxOutputAmountAForEToken",
      "maxOutputAmountAForEToken(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maxOutputAmountBForEToken(
    ePool: Address,
    eToken: Address,
    amount: BigInt
  ): BigInt {
    let result = super.call(
      "maxOutputAmountBForEToken",
      "maxOutputAmountBForEToken(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBigInt();
  }

  try_maxOutputAmountBForEToken(
    ePool: Address,
    eToken: Address,
    amount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "maxOutputAmountBForEToken",
      "maxOutputAmountBForEToken(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minInputAmountAForEToken(
    ePool: Address,
    eToken: Address,
    amount: BigInt
  ): BigInt {
    let result = super.call(
      "minInputAmountAForEToken",
      "minInputAmountAForEToken(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBigInt();
  }

  try_minInputAmountAForEToken(
    ePool: Address,
    eToken: Address,
    amount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minInputAmountAForEToken",
      "minInputAmountAForEToken(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minInputAmountBForEToken(
    ePool: Address,
    eToken: Address,
    amount: BigInt
  ): BigInt {
    let result = super.call(
      "minInputAmountBForEToken",
      "minInputAmountBForEToken(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBigInt();
  }

  try_minInputAmountBForEToken(
    ePool: Address,
    eToken: Address,
    amount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minInputAmountBForEToken",
      "minInputAmountBForEToken(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rebalanceWithFlashSwap(ePool: Address, fracDelta: BigInt): boolean {
    let result = super.call(
      "rebalanceWithFlashSwap",
      "rebalanceWithFlashSwap(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromUnsignedBigInt(fracDelta)
      ]
    );

    return result[0].toBoolean();
  }

  try_rebalanceWithFlashSwap(
    ePool: Address,
    fracDelta: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "rebalanceWithFlashSwap",
      "rebalanceWithFlashSwap(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromUnsignedBigInt(fracDelta)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  recover(token: Address, amount: BigInt): boolean {
    let result = super.call("recover", "recover(address,uint256):(bool)", [
      ethereum.Value.fromAddress(token),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);

    return result[0].toBoolean();
  }

  try_recover(token: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("recover", "recover(address,uint256):(bool)", [
      ethereum.Value.fromAddress(token),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  redeemForMinTokenA(
    ePool: Address,
    eToken: Address,
    amount: BigInt,
    minOutputA: BigInt,
    deadline: BigInt
  ): boolean {
    let result = super.call(
      "redeemForMinTokenA",
      "redeemForMinTokenA(address,address,uint256,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(minOutputA),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBoolean();
  }

  try_redeemForMinTokenA(
    ePool: Address,
    eToken: Address,
    amount: BigInt,
    minOutputA: BigInt,
    deadline: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "redeemForMinTokenA",
      "redeemForMinTokenA(address,address,uint256,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(minOutputA),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  redeemForMinTokenB(
    ePool: Address,
    eToken: Address,
    amount: BigInt,
    minOutputB: BigInt,
    deadline: BigInt
  ): boolean {
    let result = super.call(
      "redeemForMinTokenB",
      "redeemForMinTokenB(address,address,uint256,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(minOutputB),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBoolean();
  }

  try_redeemForMinTokenB(
    ePool: Address,
    eToken: Address,
    amount: BigInt,
    minOutputB: BigInt,
    deadline: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "redeemForMinTokenB",
      "redeemForMinTokenB(address,address,uint256,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(ePool),
        ethereum.Value.fromAddress(eToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(minOutputB),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  router(): Address {
    let result = super.call("router", "router():(address)", []);

    return result[0].toAddress();
  }

  try_router(): ethereum.CallResult<Address> {
    let result = super.tryCall("router", "router():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  setController(_controller: Address): boolean {
    let result = super.call("setController", "setController(address):(bool)", [
      ethereum.Value.fromAddress(_controller)
    ]);

    return result[0].toBoolean();
  }

  try_setController(_controller: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "setController",
      "setController(address):(bool)",
      [ethereum.Value.fromAddress(_controller)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  setEPoolApproval(ePool: Address, approval: boolean): boolean {
    let result = super.call(
      "setEPoolApproval",
      "setEPoolApproval(address,bool):(bool)",
      [ethereum.Value.fromAddress(ePool), ethereum.Value.fromBoolean(approval)]
    );

    return result[0].toBoolean();
  }

  try_setEPoolApproval(
    ePool: Address,
    approval: boolean
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "setEPoolApproval",
      "setEPoolApproval(address,bool):(bool)",
      [ethereum.Value.fromAddress(ePool), ethereum.Value.fromBoolean(approval)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  setMaxFlashSwapSlippage(_maxFlashSwapSlippage: BigInt): boolean {
    let result = super.call(
      "setMaxFlashSwapSlippage",
      "setMaxFlashSwapSlippage(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(_maxFlashSwapSlippage)]
    );

    return result[0].toBoolean();
  }

  try_setMaxFlashSwapSlippage(
    _maxFlashSwapSlippage: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "setMaxFlashSwapSlippage",
      "setMaxFlashSwapSlippage(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(_maxFlashSwapSlippage)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _controller(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _factory(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _router(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _keeperSubsidyPool(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _maxFlashSwapSlippage(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class IssueForMaxTokenACall extends ethereum.Call {
  get inputs(): IssueForMaxTokenACall__Inputs {
    return new IssueForMaxTokenACall__Inputs(this);
  }

  get outputs(): IssueForMaxTokenACall__Outputs {
    return new IssueForMaxTokenACall__Outputs(this);
  }
}

export class IssueForMaxTokenACall__Inputs {
  _call: IssueForMaxTokenACall;

  constructor(call: IssueForMaxTokenACall) {
    this._call = call;
  }

  get ePool(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get eToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get maxInputAmountA(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class IssueForMaxTokenACall__Outputs {
  _call: IssueForMaxTokenACall;

  constructor(call: IssueForMaxTokenACall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class IssueForMaxTokenBCall extends ethereum.Call {
  get inputs(): IssueForMaxTokenBCall__Inputs {
    return new IssueForMaxTokenBCall__Inputs(this);
  }

  get outputs(): IssueForMaxTokenBCall__Outputs {
    return new IssueForMaxTokenBCall__Outputs(this);
  }
}

export class IssueForMaxTokenBCall__Inputs {
  _call: IssueForMaxTokenBCall;

  constructor(call: IssueForMaxTokenBCall) {
    this._call = call;
  }

  get ePool(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get eToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get maxInputAmountB(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class IssueForMaxTokenBCall__Outputs {
  _call: IssueForMaxTokenBCall;

  constructor(call: IssueForMaxTokenBCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class RebalanceWithFlashSwapCall extends ethereum.Call {
  get inputs(): RebalanceWithFlashSwapCall__Inputs {
    return new RebalanceWithFlashSwapCall__Inputs(this);
  }

  get outputs(): RebalanceWithFlashSwapCall__Outputs {
    return new RebalanceWithFlashSwapCall__Outputs(this);
  }
}

export class RebalanceWithFlashSwapCall__Inputs {
  _call: RebalanceWithFlashSwapCall;

  constructor(call: RebalanceWithFlashSwapCall) {
    this._call = call;
  }

  get ePool(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get fracDelta(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RebalanceWithFlashSwapCall__Outputs {
  _call: RebalanceWithFlashSwapCall;

  constructor(call: RebalanceWithFlashSwapCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class RecoverCall extends ethereum.Call {
  get inputs(): RecoverCall__Inputs {
    return new RecoverCall__Inputs(this);
  }

  get outputs(): RecoverCall__Outputs {
    return new RecoverCall__Outputs(this);
  }
}

export class RecoverCall__Inputs {
  _call: RecoverCall;

  constructor(call: RecoverCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RecoverCall__Outputs {
  _call: RecoverCall;

  constructor(call: RecoverCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class RedeemForMinTokenACall extends ethereum.Call {
  get inputs(): RedeemForMinTokenACall__Inputs {
    return new RedeemForMinTokenACall__Inputs(this);
  }

  get outputs(): RedeemForMinTokenACall__Outputs {
    return new RedeemForMinTokenACall__Outputs(this);
  }
}

export class RedeemForMinTokenACall__Inputs {
  _call: RedeemForMinTokenACall;

  constructor(call: RedeemForMinTokenACall) {
    this._call = call;
  }

  get ePool(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get eToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get minOutputA(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class RedeemForMinTokenACall__Outputs {
  _call: RedeemForMinTokenACall;

  constructor(call: RedeemForMinTokenACall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class RedeemForMinTokenBCall extends ethereum.Call {
  get inputs(): RedeemForMinTokenBCall__Inputs {
    return new RedeemForMinTokenBCall__Inputs(this);
  }

  get outputs(): RedeemForMinTokenBCall__Outputs {
    return new RedeemForMinTokenBCall__Outputs(this);
  }
}

export class RedeemForMinTokenBCall__Inputs {
  _call: RedeemForMinTokenBCall;

  constructor(call: RedeemForMinTokenBCall) {
    this._call = call;
  }

  get ePool(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get eToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get minOutputB(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class RedeemForMinTokenBCall__Outputs {
  _call: RedeemForMinTokenBCall;

  constructor(call: RedeemForMinTokenBCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class SetControllerCall extends ethereum.Call {
  get inputs(): SetControllerCall__Inputs {
    return new SetControllerCall__Inputs(this);
  }

  get outputs(): SetControllerCall__Outputs {
    return new SetControllerCall__Outputs(this);
  }
}

export class SetControllerCall__Inputs {
  _call: SetControllerCall;

  constructor(call: SetControllerCall) {
    this._call = call;
  }

  get _controller(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetControllerCall__Outputs {
  _call: SetControllerCall;

  constructor(call: SetControllerCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class SetEPoolApprovalCall extends ethereum.Call {
  get inputs(): SetEPoolApprovalCall__Inputs {
    return new SetEPoolApprovalCall__Inputs(this);
  }

  get outputs(): SetEPoolApprovalCall__Outputs {
    return new SetEPoolApprovalCall__Outputs(this);
  }
}

export class SetEPoolApprovalCall__Inputs {
  _call: SetEPoolApprovalCall;

  constructor(call: SetEPoolApprovalCall) {
    this._call = call;
  }

  get ePool(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get approval(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetEPoolApprovalCall__Outputs {
  _call: SetEPoolApprovalCall;

  constructor(call: SetEPoolApprovalCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class SetMaxFlashSwapSlippageCall extends ethereum.Call {
  get inputs(): SetMaxFlashSwapSlippageCall__Inputs {
    return new SetMaxFlashSwapSlippageCall__Inputs(this);
  }

  get outputs(): SetMaxFlashSwapSlippageCall__Outputs {
    return new SetMaxFlashSwapSlippageCall__Outputs(this);
  }
}

export class SetMaxFlashSwapSlippageCall__Inputs {
  _call: SetMaxFlashSwapSlippageCall;

  constructor(call: SetMaxFlashSwapSlippageCall) {
    this._call = call;
  }

  get _maxFlashSwapSlippage(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetMaxFlashSwapSlippageCall__Outputs {
  _call: SetMaxFlashSwapSlippageCall;

  constructor(call: SetMaxFlashSwapSlippageCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class UniswapV2CallCall extends ethereum.Call {
  get inputs(): UniswapV2CallCall__Inputs {
    return new UniswapV2CallCall__Inputs(this);
  }

  get outputs(): UniswapV2CallCall__Outputs {
    return new UniswapV2CallCall__Outputs(this);
  }
}

export class UniswapV2CallCall__Inputs {
  _call: UniswapV2CallCall;

  constructor(call: UniswapV2CallCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value1(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get value2(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class UniswapV2CallCall__Outputs {
  _call: UniswapV2CallCall;

  constructor(call: UniswapV2CallCall) {
    this._call = call;
  }
}
